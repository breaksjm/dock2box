#!/bin/sh

exiting() {
    sh
    reboot -d 3 -f	reboot
}

trap exiting EXIT

# this is the init script version
VERSION=0.00.1
sysroot=/sysroot
ROOT=/mnt/sysimage

/bin/busybox mkdir -p /usr/bin /usr/sbin /proc /sys /dev $sysroot \
	/media/cdrom /media/usb /tmp /run
/bin/busybox --install -s

# basic environment
export PATH=/usr/bin:/bin:/usr/sbin:/sbin

# needed devs
[ -c /dev/null ] || mknod -m 666 /dev/null c 1 3

# basic mounts
mount -t proc -o noexec,nosuid,nodev proc /proc
mount -t sysfs -o noexec,nosuid,nodev sysfs /sys

# some helpers
ebegin() {
	last_emsg="$*"
	[ "$KOPT_quiet" = yes ] && return 0
	echo -n " * $last_emsg: "
}

eend() {
	local msg
	if [ "$1" = 0 ] || [ $# -lt 1 ] ; then
		[ "$KOPT_quiet" = yes ] && return 0
		echo "ok."
	else
		shift
		if [ "$KOPT_quiet" = "yes" ]; then
			echo -n "$last_emsg "
		fi
		echo "failed. $*"
		echo "initramfs emergency recovery shell launched. Type 'exit' to continue boot"
		/bin/busybox sh
	fi
}

# determine the default interface to use if ip=dhcp is set
# uses the first "eth" interface.
ip_choose_if() {
	for x in /sys/class/net/eth*; do
		[ -e "$x" ] && echo ${x##*/} && return
	done
}

# ip_set <device> <ip> <netmask> <gateway-ip>
ip_set() {
	ifconfig "$1" "$2" netmask "$3" || return $?
	if [ -n "$4" ]; then
		ip route add 0.0.0.0/0 via "$4" dev "$1" || return $?
	fi
}

# if "ip=dhcp" is specified on the command line, we obtain an IP address
# using udhcpc. we do this now and not by enabling kernel-mode DHCP because
# kernel-model DHCP appears to require that network drivers be built into
# the kernel rather than as modules. At this point all applicable modules
# in the initrd should have been loaded.
#
# You need af_packet.ko available as well modules for your Ethernet card.
#
# Valid syntaxes:
#   ip=client-ip:server-ip:gw-ip:netmask:hostname:device:autoconf
#   ip=dhcp
#   "server-ip" and "hostname" are not supported here.
#
configure_ip() {
	[ -n "$KOPT_ip" ] || return
	OIFS=$IFS
	IFS=':'
	eval set -- $KOPT_ip
	IFS=$OIFS

	local client_ip="$1"
	local gw_ip="$3"
	local netmask="$4"
	local device="$6"
	local autoconf="$7"
	case "$client_ip" in
		off|none|'') return;;
		dhcp) autoconf="dhcp";;
	esac

	[ -n "$device" ] || device=$(ip_choose_if)
	if [ -z "$device" ]; then
		echo "ERROR: IP requested but no network device was found"
		return 1
	fi

	if [ "$autoconf" = "dhcp" ]; then
		if [ ! -e /usr/share/udhcpc/default.script ]; then
			echo "ERROR: DHCP requested but not present in initrd"
			return 1
		fi

		ebegin "Set hostname based on hardware addr. ($device)"
		HOSTNAME=$(tr -d ':' < /sys/class/net/$device/address)
		hostname "$HOSTNAME"
		eend $?

		# automatic configuration
		ebegin "Obtaining IP via DHCP ($device)..."
		ifconfig $device 0.0.0.0
		udhcpc -i $device -f -q -F $HOSTNAME
		eend $?
	else
		# manual configuration
		[ -n "$client_ip" -a -n "$netmask" ] || return
		ebegin "Setting IP ($device)..."
		ip_set "$device" "$client_ip" "$netmask" "$gw_ip"
		eend $?
	fi
	MAC_ADDRESS=$(cat /sys/class/net/$device/address)
}

# Get kernel options
set -- $(cat /proc/cmdline)

myopts="quiet debug dma tmpfs_size modules usbdelay blacklist nocolor distro image registry ip gpt mdraid install sshkey"

for opt; do
	for i in $myopts; do
		case "$opt" in
		$i=*)	eval "KOPT_${i}='${opt#*=}'";;
		$i)	eval "KOPT_${i}=yes";;
		no$i)	eval "KOPT_${i}=no";;
		esac
	done
done

[ "$KOPT_quiet" = yes ] || echo "Dock2Box Init $VERSION"

# Enable debug
[ -n "$KOPT_debug" ] && set -x

# Setup keymap
ebegin "Setting US keymap"
zcat /etc/keymap/us.bmap.gz | loadkmap
eend

# No DMA
[ "$KOPT_dma" = no ] && modprobe libata dma=0

# Hide Kernel messages
[ "$KOPT_quiet" = yes ] && dmesg -n 1

# Blacklist modules
for i in ${KOPT_blacklist/,/ }; do
	echo "blacklist $i" >> /etc/modprobe.d/boot-opt-blacklist.conf
done

# Setup /dev
mount -t devtmpfs -o exec,nosuid,mode=0755,size=2M devtmpfs /dev 2>/dev/null \
	|| mount -t tmpfs -o exec,nosuid,mode=0755,size=2M tmpfs /dev
[ -d /dev/pts ] || mkdir -m 755 /dev/pts
[ -c /dev/ptmx ] || mknod -m 666 /dev/ptmx c 5 2
# make sure /dev/null is setup correctly
[ -f /dev/null ] && rm -f /dev/null
[ -c /dev/null ] || mknod -m 666 /dev/null c 1 3
mount -t devpts -o gid=5,mode=0620,noexec,nosuid devpts /dev/pts
[ -d /dev/shm ] || mkdir /dev/shm
mount -t tmpfs -o nodev,nosuid,noexec shm /dev/shm

# Load drivers
ebegin "Loading boot drivers"

modprobe -a $(echo "$KOPT_modules" | tr ',' ' ' ) 2> /dev/null
if [ -f /etc/modules ] ; then
	sed 's/\#.*//g' < /etc/modules |
	while read module args; do
		modprobe -q $module $args
	done
fi
eend 0

# Loading network drivers
ebegin "Loading network drivers"
nlplug-findfs -p /sbin/mdev ${KOPT_debug:+-d} \
        ${KOPT_usbdelay:+-t $(( $KOPT_usbdelay * 1000 ))}
#        $repoopts -a /tmp/apkovls
#eend $?
eend 0

configure_ip
ifconfig lo up

ebegin "Loading hardware drivers"
find /sys -name modalias -type f -print0 | xargs -0 sort -u \
        | xargs modprobe -b -a 2> /dev/null

# Run twice so we detect all devices
find /sys -name modalias -type f -print0 | xargs -0 sort -u \
        | xargs modprobe -b -a 2> /dev/null
eend 0

# Add dock2box user
ebegin "Add dock2box user"
adduser -D -H dock2box
chown -R dock2box:dock2box /home/dock2box
chmod 700 /home/dock2box /home/dock2box/.ssh
chmod 600 /home/dock2box/.ssh/authorized_keys
eend 0

# Start sshd
ebegin "Starting sshd"
mkdir -p /var/empty
ssh-keygen -A
/usr/sbin/sshd
eend 0

# Update CA certificates
ebegin "Update CA certificates"
mkdir -p /etc/ssl/certs
update-ca-certificates
eend 0

ebegin "Load functions"
source /functions.sh
source /functions-${KOPT_distro}.sh
eend

# Get first disk
disk0=$(get_sda_device)
if [ "$disk0" == '/dev/vda' ]; then
   disk1='/dev/vdb'
else
   disk1='/dev/sdb'
fi

# Get first interface
intf="eth0"

# Get hardware address
hwaddr=$(cat /sys/class/net/$intf/address)

info 'Wait for disk to become available'
wait_for_disk $disk0

info 'Wipe disk(s)'
wipe_lvm
clear_disk_pt $disk0

info 'Partitions disk(s)'
if [ "${KOPT_mdraid:-false}" == "true" ]; then
    info 'Using mdraid for mirroring'
    if [ "${KOPT_gpt:-false}" == "true" ]; then
        info 'Using GPT'
        partition_disk_gpt $disk0
        partition_disk_gpt $disk1
    else
        partition_disk_mbr $disk0
        partition_disk_mbr $disk1
    fi
    sleep 5s
    create_mdraid $disk0 $disk1
else
    if [ "${KOPT_gpt:-false}" == "true" ]; then
        info 'Using GPT'
        partition_disk_gpt $disk0
    else
        partition_disk_mbr $disk0
    fi
    create_lvm_vgs $disk0
fi

ebegin "Setting up logical volumes"
create_lvm_lvs
eend $?

ebegin "Setting up filesystems"
ln -s /proc/mounts /etc/mtab
create_lvm_fss
eend $?

ebegin "Mounting filesystems"
mount_fs
eend $?

ebegin "Pull Docker image and apply to disk"
docker_pull $KOPT_registry $KOPT_image latest /mnt/docker 4
eend $?

ebegin "Write network config"
conf_net $HOSTNAME $ROOT
if [ "$KOPT_ip" == "dhcp" ]; then
	conf_net_dhcp $intf $hwaddr $HOSTNAME $ROOT
else
#	conf_net_static $intf $hwaddr $KOPT_ip
	echo
fi
eend $?

ebegin "Add SSH key to dock2box user"
add_sshkey $ROOT
eend $?

ebegin "Write fstab"
write_fstab $ROOT
eend $?

sysctl -w kernel.grsecurity.chroot_caps=0

ebegin "Install bootloader"
install_grub $disk0 $ROOT "$KOPTS ${KOPT_kopts:-}"
eend $?

ebegin "Unmout filesystems"
umount_fs $ROOT
eend $?

if [ "${KOPT_debug:-false}" == "true" ]; then
	ebegin "Debug is set, start shell"
    sh
    eend 0
fi

ebegin "Done, will reboot in 3 sec."
reboot -d 3 -f
